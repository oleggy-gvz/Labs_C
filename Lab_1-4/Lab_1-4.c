/*
 * text coding: IBM866 / CP866 / csIBM866 / OEM866
 * Информатика и программирование ч.1, Лабораторная №4, вариант 3
 *
 * Задание:
 *
 */

#include <stdio.h>
#include <stdlib.h> // для заполнения псевдослучаными значениями исходного массива
#include <time.h> // для смены превдослучайных значений

// выделения памяти под массив a длиной n состоящий из типа type

// выделения памяти под массив x длиной z состоящий из типа y
#define NEW(x, y, z) { x = (y*)malloc((z) * sizeof(y)); }
// высвобождение памяти из под массива x
#define DEL(x) { free(x); x = NULL; }
// обмен значениями между собой переменных a и b
#define SWAP(type, a, b) { type tmp = a; a = b; b = tmp; }

// функция сортирует целый массив A, размерностью n, сортировкой Шейкера
void sort_shaker_mod(int *A, int n)
{
	// a - левый индекс (граница) передаваемого массива с которого начинаем сортировать
	// b - правая индекс (граница) передаваемого массива до которого производим сортировку
	int a = 0, b = n - 1;
	// индекс последнего обменяного эл-та равен левой рабочей границе поиска (a)
    // если массив уже отсортирован то после первого прохода правая граница будет равна левой (а)
    int last = a;
	int step = 1; // 1 - проход слева-направо, -1 - проход справа-налево

	while (a < b) // цикл до тех пор пока левая граница (a) не встретилась с правой (b)
	{
		// цикл сравнения пар эл-тов: левого и правого
		for (int i = (step == 1) ? a : b; (step == 1) ? i < b : i > a; i += step)
		{
			int i1, i2;
            // для поиска слева-направо сравниваем пары эл-тов текущего (левого) и следующего (правого)
            // для поиска справа-налево сравниваем пары эл-тов предыдущего (левого) и текущего (правого)
			if (step == 1) { i1 = i; i2 = i + 1; } // слева-направо
			else { i1 = i - 1; i2 = i; } // справа-налево

			if (A[i1] > A[i2]) // если левый эл-т больше правого
			{
                // меняем их местами (что бы было слева - меньший, справа - больший)
				SWAP(int, A[i1], A[i2]);
                // сохраняем этот же текущий индекс, т.к. в нем уже хранится не отсортированный эл-т
                last = i;
			}
		}
		// если проход слева-направо: изменяем границу правого (b)
		// если проход справа-налево: изменяем границу левого (a)
        if (step == 1)  b = last;
        else            a = last;

		step *= -1; // меняем направление сортировки на противоположное
	}
}

// функция наполнения целого массива a, размерностью n, случайными целыми числами из диапазона x...y
void rand_array(int *a, int n, int x, int y)
{
	srand((unsigned int)time(NULL));
	for (int i = 0; i < n; i++) a[i] = x + rand() % (y - x + 1);
}

//  функция выводит на экран значения целого массива a, размерностью n, по элементно через пробел
void show_array(char *msg, int *a, int n)
{
	printf("%s\n", msg);
	for (int i = 0; i < n; i++) printf("%3d ", a[i]);
	printf("\n");
}

// функция проверяет значения целого массива a, размерностью n, на наличие возрастания всех эл-тов (от 0...n-1)
// возвращает: истина / ложь
int check_sort(int *a, int n)
{
	int i;
	for (i = 0; a[i] <= a[i + 1] && i < n - 1; i++);
    return (int)(i == (n - 1));
}

// функция выводит на экран результат проверки целого массива a на предмет возрастания всех эл-тов (от 0...n-1)
void show_test(int *a, int n)
{
    if (check_sort(a, n) == 1) puts("массив отсортирован по возрастанию");
	else puts("массив НЕ отсортирован по возрастанию");
}

int main(void)
{
	int N = 10;
	int *A;
	NEW(A, int, N);

	rand_array(A, N, -10, 10); // наполняем массив A случайными элементами от -10 до 10
	show_array("исходный массив:", A, N);
	sort_shaker_mod(A, N); // сортируем массив сортировкой Шейкера с 1 циклом
	show_array("отсортированный массив:", A, N);
	show_test(A, N); // выводим на экран результат проверки на возрастания

	DEL(A);

	return 0;
}
