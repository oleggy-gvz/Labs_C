/*
 * text coding: IBM866 / CP866 / csIBM866 / OEM866
 * Информатика и программирование ч.1, Лабораторная №3, вариант 12
 *
 * Задание:
 *
 */

#include <stdio.h>
#include <string.h>

// выделения памяти под массив x длиной z (инициализ. '\0' символами) состоящий из типа y 
#define NEW(x, y, z) { x = (y*)malloc((z) * sizeof(y)); memset(x, '\0', (z) * sizeof(y)); }

// высвобождение памяти из под массива x
#define DEL(x) { free(x); x = NULL; }

/*
функция удаления в строке дублирующих символов, а так же одиночных в начале и в конце строки
входные: s - строка в которой будем удалять символы, с - символ который будем удалять
возвращаемое значение: новая длина строки после удаления символов
*/
int strDelDub(char *s, char c)
{
	int j = 0; // счетчик символов в новой строке
	for (int i = 0; s[i] != '\0'; i++) // перебираем все символы в строке s
	{
		if (s[i] == c) // если найден символ 'c'
		{
			if (j == 0) continue; // пропускаем все символы 'c' до первого символа
			if (s[i + 1] == c) continue; // если следом за ним тоже символ 'c' - пропускаем
		}
		s[j] = s[i];
		j++;
	}
	// ставим новое окончание строки
	if (s[j - 1] == c) j--; // если пред.символ был 'с' то уменьшаем получ. длину строки
	s[j] = '\0';
	return j; // возвращаем новую длину строки
}

/*
функция ввода строки, и удаления повторяющихся пробелов (и в начале/конце) с выводом этой строки
входные: s - исходная строка в которую будет записан результат чтения с консоли
spc - признак удаления двойных пробелов, если равен 1 - пробелы удаляем
*/
void inputStr(char *s, int spc)
{
	printf("введите строку:   ");
	if (s[0] == '\0')
        gets(s);
	else // для корректного отображения отладки
		printf("%s", s);
	printf("\nвведено:         \"%s\"\n", s);
	if (spc == 1) // если указано удаление пробелов
	{
		strDelDub(s, ' '); // удаляем повторяющиеся пробелы и в начале и конце
		printf("\nбез пробелов:    \"%s\"\n", s);
	}
}

/*
функция инвертирования строки наоборот (порядок букв наоборот)
входные: s_in - исходная строка которую будем инвертировать, 
s_out - выходная строка которую будет записано инвертированная строка из s_in
*/
void strInvert(char *s_in, char *s_out)
{
	int i, n = strlen(s_in);
	for (i = 0; i < n; i++) s_out[i] = s_in[n-1-i];
	s_out[i] = '\0';
}

/*
функция разбиения строки на подстроки, где разделитель - заданный символ
разделение происходит в том месте где есть переход от символа разделителя и символа не разделителя
или наоборот, от символа не разделителя до символа разделителя
входные: s - исходная строка которую будем разбивать на подстроки по разделителю,
с - символ разделитель, s_sub - массив подстрок в который будут записаны по отдельности все подстроки
возвращаемое значение: кол-во найденных подстрок в строке s_sub
*/
int subStr(char *s, char c, char *s_sub[])
{
	if (s[0] == '\0') return 0; // если переданная строка пустая
								// частный случай, любой 1-ый символ это всегда начало 1-ой подстроки
	s_sub[0] = &s[0]; // 1-ый символ - начало 1-ой подстроки
	int i_sub = 1; // счетчик кол-ва подстрок, уже равен 1

	for (int i = 1; s[i] != '\0'; i++) // перебираем все символы в строке s
	{
		if (s[i - 1] == '\0') // если предыдущий символ стал конецом подстроки
		{
			s_sub[i_sub] = &s[i]; // то этот символ это начало новой подстроки 
			i_sub++; // увеличиваем кол-во найденных подстрок
			continue;
		}
		if (s[i] == c) // если текущий символ разделитель
		{
			// частный случай, любой последний символ разделитель
			// не будет разделять подстроки, он будет являтся частью последней подстроки
			if (s[i + 1] == '\0') continue;
			// если предыдущий или следующий символы - не разделители
			if (s[i + 1] != c || s[i - 1] != c)
			{
				s[i] = '\0'; //  то этот символ - разделения подстрок
				continue;
			}
		}
	}
	return i_sub;
}

/*
функция инвертирования в строке всех подстрок наоборот, где разделитель пробел
входные: s_in - исходная строка которую будем преобразовывать, s_out - строка в которую будет
записана преобразованная строка
dbg - признак отладки, если равен 1, то выводим все подстроки
*/
void invertSubStr(char *s_in, char *s_out, int dbg)
{
	char **s_sub; // указатель на массив подстрок
	char *s_in_2; // строка для хранения копии переданной строки s_in
	int n, max = strlen(s_in) / 2 + 1; // макс. кол-во подстрок которое может быть в введена

	NEW(s_sub, char*, max); // создаем массив для хранения подстрок длиной max
	int m = strlen(s_in);
	NEW(s_in_2, char, m); // создаем строку для копии входной строки
	strcpy(s_in_2, s_in); // копируем входную строку что бы не менять исходную строку
	// заполняем массив подстроками
	n = subStr(s_in_2, ' ', s_sub); // и сохраняем получившееся кол-во подстрок
	for (int i = 0; i < n; i++)
	{
		char *s_inv;
		int l = strlen(s_sub[i]);
		NEW(s_inv, char, l); // создаем временную строку
        if (dbg == 1) printf("%d подстрока (%d): \"%s\"\n", i+1, l, s_sub[i]);
		strInvert(s_sub[i], s_inv);
		strcat(s_out, s_inv); // добавляем поочередно каждую инвертированную подстроку 
		if (i != n - 1) strcat(s_out, " "); // разделяем подстроки пробелом (кроме последней)
		DEL(s_inv);
	}
	DEL(s_in_2); // освобождаем строку хранения копии входной строки
	DEL(s_sub); // освобождаем массив для хранения подстрок
}

/*
функция тестирования на корректность преобразования строки по сравнению с исходной и выводом результата
тестирования
входные: s_in - исходная строка которую хотели конвертировать, s_out - получившаяся строка с 
конвертированной строкой
*/
void show_test(char *s_in, char *s_out)
{
	char *s_in_2; // строка для хранения обратного преобразования строки s_out
	 
	NEW(s_in_2, char, strlen(s_out)); // создаем строку той же длиной что s_out
	printf("преобразованная: \"%s\"\n", s_out);
    invertSubStr(s_out, s_in_2, 0);  // преобразовываем строку s_out в s_in_2
	printf("преобраз.повтр.: \"%s\"\n", s_in_2);
	if (!strcmp(s_in, s_in_2)) puts("тест пройден, преобразование корректно");
	else puts("тест НЕ пройден, преобразование НЕ корректно");
	DEL(s_in_2); // освобождаем строку хранения копии входной строки
}

int main(void)
{
	//char s_in[80] = "    123 45   6 87  АбвГд "; // входная строка для отладки, тест проходит
	//char s_in[80] = "    123 45   6  87  АбвГд "; // входная строка для отладки, тест НЕ проходит

    char s_in[80] = {'\0'}; // входная строка
    char *s_out; // выходная строка, в ней будет хранится результат

	// второй параметер: 0 - не удаляем дубликаты пробелов, 1 - удаляем
    inputStr(s_in, 0); // ввод данных
	NEW(s_out, char, strlen(s_in)); // выделяем память для хранения результата
    invertSubStr(s_in, s_out, 0); // получаем преобразованную строку s_in в s_out
	show_test(s_in, s_out); // выводим результаты теста
	DEL(s_out); // освобождаем строку хранения выходной строки

	return 0;
}
