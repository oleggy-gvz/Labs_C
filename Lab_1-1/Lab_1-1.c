/*
 * text coding: IBM866 / CP866 / csIBM866 / OEM866
 * Информатика и программирование ч.1, Лабораторная №1, вариант 5
 *
 * Задание:
 *
 */

#include <stdio.h>
#include <math.h>

#define INT_MAX 0x7FFFFFFF

/*
функция проверяет число n, является ли оно простым или составным
ф-ция возвращает true если число n - простое, false если число n - составное
*/
int isPrimeNumber(int n)
{
	int i;
    int m = (int)(sqrt(n) + 1); // m - ближайшее целое после квад. корня n
	for (i = 2; i < m && n % i != 0; i++); // перебираем все делители от 2 до m которые делят без остатка n

    return (int)(i == m);  // если перебрали все делители, значить число i - простое (true), иначе (false)
}

/* 
функция ищет все наименьшие простые делители для числа a
возвращает по ссылке заполненный массив k содержащий все простые делители (должен быть проинициализирован заранее),
кол-во найденных простх делителей n
ф-ция возвращает -1, если число a меньше 2,
                  0, если число а было составным (успешно разбито)
                  1, если число а было простым
*/
int getPrimeDivisors(int a, int k_arr[], int *n)
{
	if (a < 2) return -1; // возвращает -1 если число меньше 2
	int i, k;	
	// наполняем массив k_arr наименьшими простыми делителями для числа a, до тех пока число а не станет простым
    for (i = 0; isPrimeNumber(a) != 1; i++)
	{
		for (k = 2; k < a; k++) // перебор всех делителей от 2 до a-1
		{
			// если текущ. k простое число и при делении a на k - нет остатка, то нашли
            if (isPrimeNumber(k) == 1 && a % k == 0) break;
		}
		k_arr[i] = k; // сохраняем этот делитель в массив
		a /= k; // делим число a на делитель k, что бы перейти к следующему шагу
	}
	k_arr[i] = a; // добавляем последнее число a в массив, т.к. оно простое, оно и есть последний делитель
    *n = i + 1; // возвращаем кол-во элементов массива k_arr

    return (int)(i == 0); // если перебора не было, значить число a - простое (1), иначе a был составным (0)
}

void imput(int *a)
{
	printf("Введите число: ");
    scanf("%d", a);
}

void output(int a, int k_arr[], int n, int r)
{
	switch (r)
	{
	case 0:
		printf("Простые множители (%d): ", n);
		for (int i = 0; i < n; i++)
		{
			printf("%d", k_arr[i]);
			if (i < n-1) printf(", ");
		}
		break;
	case 1:
		printf("Число %d - простое", a);
		break;

	case -1:
        printf("Число должно быть в диапазоне от 2 до %d", INT_MAX);
		break;
	}
	printf("\n");
}

/*
функция тестирования, произведение всех между собой элементов массива k_arr длинной n
и сверка результата из переменной a
*/
void test(int a, int k_arr[], int n)
{
	int c = 1; // результат произведения всех делителей
	for (int i = 0; i < n; i++) c *= k_arr[i]; // перемножаем все эл-ты массива

	printf("Тест %s: ", (a == c) ? "пройден" : "НЕ пройден");

	// отображение проверки вида: k1 * k2 * ... * kN = c
	for (int i = 0; i < n; i++)
	{
		printf("%d", k_arr[i]);
		(i < n - 1) ? printf(" * ") : printf(" = "); // если последний множитель, то после него ставим знак =
	}
	printf("%d", c); // после знака = ставим само получившееся число с
	if (a != c) printf(" (%d != %d)", c, a); // если тест не пройден то добавляем запись вида (с != a)
	printf("\n");
}

int main(void)
{
	int A, K[20], num_K;
	int res;

    imput(&A); // ввод данных
    res = getPrimeDivisors(A, K, &num_K);  // получаем массив простых делителей K с размерностью num_K
	output(A, K, num_K, res); // вывод данных с обработкой ошибок из res
	if(res == 0) test(A, K, num_K); // если число было найдено, проводим тест

    return 0;
}
